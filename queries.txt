/*Выведите все фамилии служащих, в которых есть буквы "a" и "y"*/
select LAST_NAME from hr.employees where LAST_NAME like '%a%' and LAST_NAME like '%y%'

/**/

Выведите фамилии и номера служащих вместе с фамилиями и номерами их менеджеров. Назовите столбцы Employee, Emp#, Manager и Mgr#
select emp.LAST_NAME as Employee, emp.EMPLOYEE_ID as Emp#, mngr.LAST_NAME as Manager, mngr.EMPLOYEE_ID as Mgr# from hr.employees emp
join hr.employees mngr
on emp.MANAGER_ID = mngr.EMPLOYEE_ID;

/**/

Отделу HR необходим отчет, в котором выводятся фамилии, номера отделов и должности служащих, идентификатор местоположения отдела которых равен 1700.
select emp.LAST_NAME, emp.DEPARTMENT_ID, emp.JOB_ID from employees emp
join DEPARTMENTS dpt
on dpt.DEPARTMENT_ID = emp.DEPARTMENT_ID
where dpt.LOCATION_ID = 1700

/**/

"Вывести фамилию сотрудника и рассчитать количество месяцев между
сегодня и датой его найма. Столбец c количеством месяцев назвать MONTHS_WORKED. Отсортировать данные по 2-му полю. Округлить до ближайшего целого."
select LAST_NAME, round(MONTHS_BETWEEN(CURRENT_DATE, HIRE_DATE)) as MONTHS_WORKED from EMPLOYEES order by MONTHS_WORKED 

/**/

Отделу HR необходим отчет, в котором выводится следующее: - фамилии и отделы всех сотрудников из таблицы EMPLOYEES, независимо от того, относятся ли они к какому-то отделу или нет; - номера и наименования всех отделов из таблицы DEPARTMENTS, независимо от того, есть ли в них сотрудники или нет. Для получения отчета напишите составной запрос.
SELECT LAST_NAME, department_id, NULL
FROM employees
UNION
SELECT NULL, department_id, department_name
FROM departments

/**/

Команда SELECT содержит 4 ошибки:

SELECT employee_id, last_name
sal x 12 ANNUAL SALARY
FROM employees

Исправьте их.
SELECT EMPLOYEE_ID, LAST_NAME,
(SALARY * 12) as "ANNUAL SALARY"
FROM employees

/**/

Отделу по работе с персоналом (Human Resources, HR) необходимы данные, включающие фамилию, код должности, дату найма и табельный номер для каждого служащего. Табельный номер должен выводиться первым. Определите псевдоним STARTDATE для столбца HIRE_DATE.
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, HIRE_DATE as STARTDATE FROM employees

/**/

Отдел по работе с персоналом запрашивает данные о всех должностях из таблицы EMPLOYEES. В выводимых результатах идентификаторы должностей не должны повторяться.
SELECT JOB_ID FROM employees group by JOB_ID

/**/

Отделу HR необходимы соответствующие заголовки в отчете о служащих. Назовите столбцы Emp #, Employee, Job и Hire Date. Отсортируйте по первому полю.
SELECT EMPLOYEE_ID as Emp#, LAST_NAME as Employee, JOB_ID as Job, HIRE_DATE as "Hire Date" FROM employees order by EMPLOYEE_ID

/**/

Отделу HR необходим отчет о всех сотрудниках и идентификаторах их должностей. Выведите на экран имя, соединенное с идентификатором должности через запятую и пробел. Назовите новый столбец Employee and Title.
SELECT (FIRST_NAME||', '||JOB_ID) as "Employee and Title" FROM employees

/**/

Создайте запрос для вывода всех данных из таблицы EMPLOYEES, чтобы познакомиться с ее содержимым таблицы.
Разделите значения столбцов запятыми и выведите их в одном столбце с наименованием THE_OUTPUT
SELECT employee_id || ',' || first_name || ',' || last_name || ','|| email || ',' || phone_number || ',' || hire_date || ',' || job_id || ',' || salary || ',' || commission_pct || ',' || manager_id || ','|| department_id "THE_OUTPUT" from employees

/**/

Вследствие проблем финансирования отделу HR необходим отчет, в котором показываются фамилии и оклады служащих, получающих более $12,000. Выполните запрос.
select LAST_NAME, SALARY from employees where SALARY > 12000


/**/

Создайте запрос для вывода фамилии и номера отдела служащего под номером 176
select LAST_NAME, DEPARTMENT_ID from employees where EMPLOYEE_ID = 176

/**/

Отделу HR необходимы данные о высокооплачиваемых и низкооплачиваемых сотрудниках. Выведите фамилии и оклады всех служащих, чей оклад не входит в диапазон от $5000 до $12000.
select LAST_NAME, SALARY from EMPLOYEES where SALARY < 5000 or SALARY > 12000

/**/

Создайте отчет для вывода фамилии, идентификатора должности и даты начала работы всех служащих, с фамилиями Matos и Taylor. Отсортируйте данные в порядке возрастания даты найма.
select LAST_NAME, JOB_ID, HIRE_DATE from EMPLOYEES where LAST_NAME like 'Matos' or LAST_NAME like 'Taylor' order by HIRE_DATE

/**/

Выведите фамилию и номер отдела всех служащих из отделов 20 и 50. Отсортируйте данные по фамилиям в алфавитном порядке.
select LAST_NAME, DEPARTMENT_ID from EMPLOYEES where DEPARTMENT_ID = 20 or DEPARTMENT_ID = 50 order by LAST_NAME

/**/

Выведите фамилии и оклады служащих отделов 20 и 50 , зарабатывающих от $5000 до $12,000. Назовите столбцы Employee и Monthly Salary, соответственно.
select LAST_NAME as "Employee", SALARY as "Monthly Salary" from EMPLOYEES where (DEPARTMENT_ID = 20 or DEPARTMENT_ID = 50) and (SALARY > 5000 and SALARY < 12000)

/**/

Отделу HR необходим отчет, в котором выводятся фамилии и даты найма всех служащих, нанятых в 1994 г.
select LAST_NAME, HIRE_DATE from EMPLOYEES where HIRE_DATE >= date '1994-01-01' and HIRE_DATE <= date '1995-01-01'

/**/

Создайте отчет, содержащий фамилии и должности всех служащих, не имеющих менеджера.
select LAST_NAME, JOB_ID from EMPLOYEES where MANAGER_ID is null

/**/

Создайте отчет для вывода фамилий, окладов и комиссионные всех служащих, зарабатывающих комиссионные. Отсортируйте данные в порядке убывания окладов и комиссионных.
select LAST_NAME, SALARY, COMMISSION_PCT from EMPLOYEES where COMMISSION_PCT is not null order by SALARY desc, COMMISSION_PCT desc 

/**/

Выведите все фамилии служащих, в которых третья буква – a.
select LAST_NAME from employees where LAST_NAME like '__a%'

/**/

Выведите все фамилии служащих, в которых есть буквы “a” и “e”.
select LAST_NAME from employees where LAST_NAME like '%a%' and LAST_NAME like '%e%'

/**/

Запросите фамилии, должности и оклады всех служащих, работающих торговыми представителя (SA_REP) или клерками на складе (ST_CLERK), у которых не может быть равен $2500, $3500 или $7000
select LAST_NAME,JOB_ID,SALARY from EMPLOYEES where (JOB_ID like 'SA_REP' or JOB_ID like 'ST_CLERK') and (SALARY != 2500 and SALARY != 3500 and SALARY != 7000)

/**/

Получите фамилии, оклады и комиссионные всех служащих, у которых сумма комиссионных составляет 20 %.
select LAST_NAME,SALARY,COMMISSION_PCT from EMPLOYEES where COMMISSION_PCT = 0.2

/**/

Напишите запрос для вывода текущей даты. Назовите столбец Date.
select current_date as "Date" from dual

/**/

Отделу HR требуется отчет, в котором приводится номер служащего, его фамилия, оклад и новый оклад, повышенный на 15% и округленный до целого. Столбец в отчете, содержащий новый оклад, должен иметь имя New Salary.
select EMPLOYEE_ID, LAST_NAME, SALARY, round(SALARY * 1.15) as "New Salary" from employees

/**/

Отделу HR требуется отчет, в котором приводится номер служащего, его фамилия, оклад и новый оклад, повышенный на 15% и округленный до целого. Столбец в отчете, содержащий новый оклад, должен иметь имя New Salary. Добавьте еще один столбец, который будет содержать результат вычитания старого оклада из нового. Назовите столбец Increase.
select EMPLOYEE_ID, LAST_NAME, SALARY, round(SALARY * 1.15) as "New Salary", ((SALARY * 1.15) - SALARY) as "Increase" from employees

/**/

Выведите фамилии служащих (первая буква каждой фамилии должна быть заглавной, а остальные - строчными) и длину каждой фамилии для тех служащих, фамилия которых начинается с символа J, A или M. Присвойте соответствующие заголовки столбцам. Отсортируйте результат по фамилиям служащих.
select INITCAP(LAST_NAME), LENGTH(LAST_NAME) from employees where LAST_NAME like 'J%' or LAST_NAME like 'A%' or LAST_NAME like 'M%' order by LAST_NAME


/**/

Получите по каждому служащему отчет в следующем виде: <фамилия> зарабатывает <оклад> в месяц, но желает <утроенный оклад>. Назовите столбец Dream Salaries.
select (LAST_NAME||' earns'||to_char(SALARY, '$99G999D99')||' monthly but wants'||to_char(SALARY*3, '$99G999D99')||'.') as "Dream salaries" from EMPLOYEES 
не работает

/**/

Напишите запрос для вывода фамилий и окладов всех служащих. Cтолбец, содержащий оклад назовите SALARY. Длина столбца SALARY – 15 символов с дополненными слева символами $.
select last_name, lpad(salary,15,'$') salary from employees 

/**/

Для каждого служащего выведите фамилию, дату найма и дату пересмотра зарплаты, 
которая приходится на первый понедельник после шести месяцев работы. Назовите столбец REVIEW. 
Формат даты при выводе имеет вид: “Monday, the Thirty-First of July, 2000.”

SELECT last_name,
TO_CHAR (hire_date, 'DD-MON-YY', 'NLS_DATE_LANGUAGE=american') hire_date,
TO_CHAR (NEXT_DAY (ADD_MONTHS (hire_date, 6), 'Monday'), 'fmDay, "the" Ddspth "of" Month, YYYY', 'NLS_DATE_LANGUAGE=american') as REVIEW
FROM hr.employees;

проверить

/**/

По каждому служащему выведите фамилию, дату найма и день недели (на английском языке), когда он был нанят на работу. Назовите последний столбец DAY. Отсортируйте результаты по дням недели, начиная с понедельника.
select LAST_NAME, HIRE_DATE, (to_char(HIRE_DATE, 'DAY')) as Day from hr.EMPLOYEES order by mod(to_char(HIRE_DATE, 'D') + 5, 7)

не работает 

/**/

Напишите запрос для вывода фамилии и суммы комиссионных каждого служащего. Если служащий не зарабатывает комиссионных, укажите в столбце “No Commission.” Назовите столбец COMM.
select last_name, NVL(to_char(commission_pct,'fm.99'),'No Commission')COMM from employees 

/**/

Используя функцию DECODE, напишите запрос для отображения должности сотрудника и ее разряда (grade). Разряд каждого типа должности JOB_ID приведен в таблице:
Должность Разряд
AD_PRES A
ST_MAN B
IT_PROG C
SA_REP D
ST_CLERK E
Другая 0

select JOB_ID, DECODE(JOB_ID, 
                    'AD_PRES', 'A',
                    'ST_MAN', 'B',
                    'IT_PROG', 'C',
                    'SA_REP', 'D',
                    'ST_CLERK', 'E',
                    '0') result
from employees 

/**/

Напишите запрос для вывода самого высокого, самого низкого и среднего оклада по всем служащим, а также суммы всех окладов. Назовите столбцы Maximum, Minimum, Sum и Average. Округлите суммы до ближайшего целого значения.
select round(MAX(SALARY)) as Maximum, round(MIN(SALARY)) as Minimum, round(SUM(SALARY)) as Sum, round(AVG(SALARY)) as Average from hr.EMPLOYEES 

не работает

/**/

Напишите запрос для вывода должности и количества служащих, занимающих каждую должность. Отсортируйте результат по должностям в порядке возрастания.
select JOB_ID, count(EMPLOYEE_ID) from EMPLOYEES group by JOB_ID order by JOB_ID

/**/

Получите количество служащих, имеющих подчиненных, без их перечисления. Назовите столбец Number of Managers. Подсказка: используйте столбец MANAGER_ID для определения числа менеджеров.
SELECT COUNT (DISTINCT manager_id) "Number of Managers"
FROM employees

/**/

Напишите запрос для вывода разности между самым высоким и самым низким окладами. Назовите столбец DIFFERENCE.
select (MAX(SALARY) - MIN(SALARY)) as DIFFERENCE from EMPLOYEES

/**/

Напишите запрос для вывода номера каждого менеджера и заработной платы самого низкооплачиваемого из его подчиненных. Исключите всех, для которых неизвестны их менеджеры. Исключите все группы, где минимальный оклад составляет менее $6000. Отсортируйте выходные строки в порядке убывания оклада.
select manager_id, min(SALARY) from employees
where MANAGER_ID is not null
group by manager_id
having  min(SALARY) > 6000 
order by min(SALARY) desc

/**/





















